package com.company;
import java.lang.reflect.Array;
import java.util.*;


class Job {
    String jobName;
    int jobLength;
    int currentJobLength;
    int jobPriority;
    int finalPriority;
    long entryTime;
    long endTime = 0;
    long waitTime = 0;
    long currentTime = 0;
    int index;


    public Job(int i) { // Job object
        setName(i+1);
        setLength();
        setCurrentLength();
        setPriority();
        setFinalPriority();
        setEntryTime(i);
        setEndTime(0);
        setWaitTime(0);
        setCurrentTime(i);
        setIndex(i);
    }

    public void setIndex(int index){
        this.index = index;
    }

    public int getIndex(){
        return this.index;
    }

    public void setName(int i){
        this.jobName = "Job_" + i;
    }


    public String getName(){
        return this.jobName;
    }


    public void setLength() {
        int min = 1;
        int max = 70;
        this.jobLength = (int) (Math.random() * max + min);
    }

    public int getLength() {
        return this.jobLength;
    }

    public void setCurrentLength() {
        this.currentJobLength = getLength();
    }

    public int getCurrentLength(){
        return this.currentJobLength;
    }

    public void setPriority() {
        int min = 1;
        int max = 40;
        this.jobPriority = (int) (Math.random() * max + min);
    }

    public int getPriority() {
        return this.jobPriority;
    }

    public void setFinalPriority() {
        this.finalPriority = getPriority();
    }

    public int getFinalPriority(Job job) {
        return this.finalPriority;
    }

    public void setEntryTime(int i){
        this.entryTime = i;
    }

    public long getEntryTime() {
        return this.entryTime;
    }

    public void setEndTime(int i){
        this.endTime = i;
    }

    public long getEndTime() {
        return this.endTime;
    }

    public void setWaitTime(int i){
        this.waitTime = i;
    }

    public long getWaitTime() {
        return this.waitTime;
    }

    public void setCurrentTime(int i){
        this.currentTime = i;
    }

    public long getCurrentTime(){
        return this.currentTime;
    }

}

class PriorityQueueSimulatorTester {
    int MaxNumberOfJobs;
    long currentTime = 0;
    List<Job> jobsInputArray = new LinkedList<>();

    public PriorityQueueSimulatorTester(int MaxNumberOfJobs){
        this.MaxNumberOfJobs = MaxNumberOfJobs;
        this.jobsInputArray = setJobsInputArray(jobsInputArray);
    }

    public int getArraySize() {
        return MaxNumberOfJobs;
    }

    public Job getJobAtIndex(int i){
        return jobsInputArray.get(i);
    }

    // list implementation
    public List<Job> setJobsInputArray(List<Job> jobsInputArray) {
        for (int i = 0; i < MaxNumberOfJobs; i++) {
            Job newJob = new Job(i);
            jobsInputArray.add(newJob);
        }
        return jobsInputArray;
    } // the list will be an unsorted list
}

class Heap {
    List<Job> jobArray = new ArrayList<>();

    public Heap(PriorityQueueSimulatorTester testerQueue) {
        for (int i = 0; i < testerQueue.getArraySize(); i++)
            this.jobArray.add(testerQueue.getJobAtIndex(i));
        int index = (testerQueue.getArraySize() / 2) - 1;
        for (int i = index; i >= 0; i--) {
            sortTheHeap(i);
        }
    }

    public void sortTheHeap(int currentIndex) {
        int largest = currentIndex; // Initialize largest as root
        int left_child = 2 * currentIndex + 1;
        int right_child = 2 * currentIndex + 2;

        if (left_child < this.jobArray.size() && this.jobArray.get(left_child).getPriority() > this.jobArray.get(largest).getPriority())
            largest = left_child;

        if (right_child < this.jobArray.size() && this.jobArray.get(right_child).getPriority() > this.jobArray.get(largest).getPriority())
            largest = right_child;

        // If largest is not root
        if (largest != currentIndex) {
            Job buffer = this.jobArray.get(currentIndex);
            this.jobArray.set(currentIndex, this.jobArray.get(largest));
            this.jobArray.set(largest, buffer);
            sortTheHeap(largest);
        }
    }

    public void printHeap() {
        System.out.println("Array representation of Heap is:");

        for (Job job : this.jobArray)
            System.out.println(job.getName() + "\t\tPriority: " + job.getPriority() + "   \t\tLength: " + job.getLength());
    }
}

class SortedList{
    List<Job> jobArray;

    public SortedList(PriorityQueueSimulatorTester testerQueue) {
        List<Job> bufferArray = new ArrayList<>();
        // higher priority at the en of the queue
        for (int priority = 40; priority >= 1; priority--) {
            //go through all the array searching for the priority from 1 to 40 -> complexity of 40n -> O(n)
            for (int i = 0; i < testerQueue.getArraySize(); i++) {
                if (testerQueue.getJobAtIndex(i).getPriority() == priority)
                    // we will then sort the list in term of priority in a new list
                    bufferArray.add(testerQueue.getJobAtIndex(i));
            }
        }
        this.jobArray = bufferArray;
    }

    public void printList() {
        System.out.println("Sorted list representation of Heap is:");

        for (Job job : this.jobArray)
            System.out.println(job.getName() + "\t\tPriority: " + job.getPriority() + "   \t\tLength: " + job.getLength());
    }
}

public class Main {

    public static void main(String[] args) {
        PriorityQueueSimulatorTester testerQueue = new PriorityQueueSimulatorTester(100);


        SortedList sorted_list = new SortedList(testerQueue);  // higher priority at the end of the queue
        sorted_list.printList();// sorted list as an Array List based on the priority

        Heap heap=new Heap(testerQueue); // unsorted array based heap
        heap.printHeap();  // (higher priority at the leaves)


    }
}
